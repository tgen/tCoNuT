function [cna,amp,del,dlr,log2fc,bafFreq]=cnaMedianCenter(normal,tumor,smWin,fcThresh,assayID,res,readDepth,intronLength,hetFile,hetDepthN,hetDepthT,hetDev,targetsFile)
% [cna,amp,del,noise,log2fc,bafFreq]=cnaMedianCenter(normal,tumor,smWin,fcThresh,assayID,res,readDepth,intronLength,hetFile,hetDepthN,hetDepthT,hetDev,targetsFile)
%
%   Copy Number Analysis (CNA) for next-generation sequencing (NGS) data.
%   Algorithm is designed to work on exome, custome panels and whole genome
%   sequencing (WGS).
%
%   INPUTS:
%       normal is a N x 3 matrix where first column is chromosome, second
%       column is position and third column is number of reads at that
%       position.
%
%       tumor is a N x 3 matrix where first column is chromosome, second
%       column is position and third column is number of reads at that
%       position.
%
%       smWin is the size of a sliding window (e.g. 6 for exomes and 19 for WGS).
%       
%       fcThresh is the threshold where 'amp' and 'del' are determined for
%       plotting purposes.
%   
%       assayID is the type of assay.  Options are Genome or Exome
%
%       res is the factor that sets the starting size of the window of
%       positions evaluated for averaging then increments window size by 1
%       until average reaches readDepth.  Window size units are 100 bases
%       Example is a window size of 3 is equivalent to 300 bases, so setting
%       res=2 intitial window size will be 3 (1:1+2) then incremented from
%       there 1:1+2+i where i=i+1.
%
%       readDepth is the maximum read depth for window when incrementing window size.
%
%       intronLength is the maximum distance (in bases) allowed between positions when
%       incrementing window size. This accounts for introns in exome data
%       and centromeres in whole genome data. 
%
%       hetFile is M x 8 matrix contain the allele frequencies of
%       heterzygous SNPs identified in the control sample and allele
%       frequencies of tumor sample at corresponding locations. Columns are
%       as follows: chromosome, position, read depth of control sample,
%       control reference allele frequency, control alternate allele
%       frequency, read depth of affected sample, affected reference allele
%       frequency, and affected alternate allele frequency. This input can
%       be read in from merged.vcf.txt generated by parseMergeVCF.pl. If
%       merged.vcf.txt is not available, hetFile needs to equal 0.
%
%       hetDepthN is an estimate of read depth over SNP in control sample.
%       This value is used to set thresholds for filtering SNPs used for
%       centering.  For example with exome data the average target coverage
%       can be used and for genome physical coverage can be used.
%
%       hetDepthT is an estimate of read depth over SNP in affected sample.
%       This value is used to set thresholds for filtering SNPs used for
%       centering.  For example with exome data the average target coverage
%       can be used and for genome physical coverage can be used.
%
%       hetDev is allowable deviation from a 0.5 allele frequency in the
%       affected sample for a SNP used for centering.  For example if set
%       to 0.025 the thresholds for filtering will be 0.475 < SNP allele
%       frequency < 0.525.
%
%       targetsFile is M x 4 matrix where columns are as follows:
%       chromosome, start position, end position, and index. The index
%       column contains 0 or >0 where all regions with a 0 are
%       filtered from the analysis.  This matrix is usually created by
%       reading in a BED file generated to indicate areas of the genome not
%       covered by an assay.  For example, exome data will need this BED
%       file created from the Targets BED file provided by manufacturer.
%       This file can also be used to filter regions from the genome such
%       as common structural variant regions or regions with poor mapping.
%
%   OUTPUT:
%       cna is a M x 3 matrix where the first column is chromosome, second
%       column is position and third column is log2 fold-change. 
%
%       amp is a M x 3 matrix where the first column is chromosome, second
%       column is position and third column is log2 fold-change.  amp
%       contains only those locations where log2 fold-change > fcThresh.
%
%       del is a M x 3 matrix where the first column is chromosome, second
%       column is position and third column is log2 fold-change.  amp
%       contains only those locations where log2 fold-change < fcThresh.
%
%       dlr is derivative log ratio noise estimate.
%	
%       log2fc is a M x 3 matrix where the first column is chromosome, second
%       column is position and third column is log2 fold-change at position of a
%       het in the normal or control sample. Median value of log2 fold-changes is 
%       used to center the data. log2fc will only be available if a hetFile
%       is not equal to 0.
%
%       bafFreq is the N x 3 matrix where the first column is chromosome, second
%       column is position and third column is b-allele frequency (or alternative
%       allele frequency). bafFreq will only be available if a hetFile is
%       not equal to 0.
%

% [2010] - [2016] Translational Genomics Research Institute (TGen)
% All Rights Reserved.
%
% Major Contributor(s):
%    Jessica Aldrich, David W. Craig, Jonathan Keats
% Minor Contributor(s):

% Calculate fold change
paira=cat(2,normal(:,1:3),tumor(:,3));

% Filter paira if targetsFile provided
switch lower(assayID)
    case 'exome'
        overlap=load(targetsFile);
        paira(~logical(overlap(:,4)),:)=[];
        
    case 'genome'
        if nargin==13
            pos=load(targetsFile);
            paira=paira(logical(pos),:);
        
        end
        low=10;
        inc_ploid=0.8;
        %remove aneuploidy regions in normal sample in autosomal chrs
        autochr = paira(:,1)<20;
        autochrs = paira(autochr,:);
        norm_mode=mode(autochrs(autochrs(:,3)>low,3));
        a=autochrs(autochrs(:,3)>norm_mode*inc_ploid & autochrs(:,3) < norm_mode*(1/inc_ploid),:);
        
        %remove aneuploidy regions in normal sample in sex chrs
        sexchr = paira(:,1)>=20;
        sexchrs = paira(sexchr,:);
        norm_mode=mode(sexchrs(sexchrs(:,3)>low,3));
        b=sexchrs(sexchrs(:,3)>norm_mode*inc_ploid & sexchrs(:,3) < norm_mode*(1/inc_ploid),:);
        
        paira = [a;b];
end

pairb=zeros(size(paira));
count=1;

%Resample across each chromosome
%%%%for chr=1:24 %HUMAN SPECIFIC
numChr = length(unique(paira(:,1))); %% Dynamically detect number of CHR
for chr=1:numChr
    
    a=1; %set window initial starting position
    b=1; %set window initial ending position
    chrom=paira(paira(:,1)==chr,:);

    %walk down chromosome averaging positions with distance(intronLength)
    %and read depth(readDepth)constraints
    while b<=size(chrom,1) && a<size(chrom,1)
        if a+res<=size(chrom,1)
            b=a+res;
            while b<size(chrom,1) && chrom(b+1,2)-chrom(b,2) < intronLength && sum(chrom(a:b,3)) < readDepth
                b=b+1;
                if b>size(chrom,1)
                    b=size(chrom,1);
                end
            end
            npt = [chrom(a,1) round(median(chrom(a:b,2))) round(mean(chrom(a:b,3:4)))];  %%%%MEAN CAN BE CHANGED - SUM, MEAN, MEDIAN
            pairb(count,:) = npt;
            count=count+1;
        else
            b=size(chrom,1);
            npt = [chrom(a,1) round(median(chrom(a:b,2))) round(mean(chrom(a:b,3:4)))];  %%%%MEAN CAN BE CHANGED - SUM, MEAN, MEDIAN
            pairb(count,:) = npt;
            count=count+1;
        end
        a=b;
    end
end

%remove NaN
pairb(~logical(pairb(:,1)),:)=[];

%Normalize for library size for each sample
for j=3:4
   pairb(isnan(pairb(:,j)),j)=0;
   pairb(:,j)=pairb(:,j)./sum(pairb(:,j));
end

%Calculate log2(affected/control)
paira=pairb;
paira(:,4)=log2(paira(:,4)./paira(:,3));
cna=paira(isfinite(paira(:,4)),[1,2,4]);
 
log2fc=[];

% Filter hets for median center data
if hetFile   %if hetFile is 0 - skip median centering
    switch lower(assayID)
        case 'exome'
            fid = fopen(hetFile);
            vcf = textscan(fid,'%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f','headerlines',1);
            fclose(fid);
            vcfMat =cell2mat(vcf);
            
            %adjust to expand or contract window of excepted allele frequency
            minAllFreq=0.5-hetDev;
            maxAllFreq=0.5+hetDev;
            
            allFreq = [vcfMat(:,4)./sum(vcfMat(:,4:5),2) vcfMat(:,7)./sum(vcfMat(:,7:8),2)];
            bafFreq = [vcfMat(:,1) round(vcfMat(:,2)/100)*100 vcfMat(:,8)./sum(vcfMat(:,7:8),2)];
            sumDepth = [sum(vcfMat(:,4:5),2) sum(vcfMat(:,7:8),2)];
            ind = sumDepth(:,1)>hetDepthN & sumDepth(:,1)< hetDepthN+(0.5*hetDepthN) & ...
                  sumDepth(:,2)>hetDepthT & sumDepth(:,2)< hetDepthT+(0.5*hetDepthT) & ...
                  allFreq(:,2)>minAllFreq & allFreq(:,2)<maxAllFreq;

        case 'genome'
            fid = fopen(hetFile);
            vcf = textscan(fid,'%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f','headerlines',1);
            fclose(fid);
            vcfMat =cell2mat(vcf);
            
            minAllFreq=0.5-hetDev;
            maxAllFreq=0.5+hetDev;
            
            allFreq = [vcfMat(:,4)./sum(vcfMat(:,4:5),2) vcfMat(:,7)./sum(vcfMat(:,7:8),2)];
            bafFreq = [vcfMat(:,1) round(vcfMat(:,2)/100)*100 vcfMat(:,8)./sum(vcfMat(:,7:8),2)];
            sumDepth = [sum(vcfMat(:,4:5),2) sum(vcfMat(:,7:8),2)];
          
            ind = sumDepth(:,1)>hetDepthN-(0.3*hetDepthN) & sumDepth(:,1)< hetDepthN+(0.3*hetDepthN) & ...
                  sumDepth(:,2)>hetDepthT-(0.3*hetDepthT) & sumDepth(:,2)< hetDepthT+(0.3*hetDepthT) & ...
                  allFreq(:,2)>minAllFreq & allFreq(:,2)<maxAllFreq;                                
    end

    vcfMatFilt = vcfMat(ind,:);
    vcfMatFilt = [vcfMatFilt(:,1) round(vcfMatFilt(:,2)/10000)*10000 vcfMatFilt(:,3:end)];

    vcfMatFiltVect = vcfMatFilt(:,1)*1000000000+vcfMatFilt(:,2);
    nm = cna(:,1)*1000000000+round(cna(:,2)/10000)*10000;

    [~,hets] = intersect(nm,vcfMatFiltVect);
    log2fc = cna(hets,:); 
   
    %Median center data    
    if length(hets) > 4
        cna(:,3) = cna(:,3)-median(log2fc(:,3));
    end
end

% Median smoothing per chromosome
for i = 1:length(unique(cna(:,1)))
    chr = cna(:,1)==i;
    if sum(chr) > 2*smWin
        cna(chr,3) = roll_med(cna(chr,3),smWin);
    end
end

amp = cna(cna(:,3)>fcThresh,:);
del = cna(cna(:,3)<-fcThresh,:);

% Calculate noise measure (DLRS)
cna = cna(isfinite(cna(:,3)),:);
dlr = dlrs(cna(1:(2*smWin)+1:end,3));

end %end of function



